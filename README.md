```
  _____                              _____            _             _ _           
 |  __ \                            / ____|          | |           | | |          
 | |__) | __ ___   ___ ___  ___ ___| |     ___  _ __ | |_ _ __ ___ | | | ___ _ __ 
 |  ___/ '__/ _ \ / __/ _ \/ __/ __| |    / _ \| '_ \| __| '__/ _ \| | |/ _ \ '__|
 | |   | | | (_) | (_|  __/\__ \__ \ |___| (_) | | | | |_| | | (_) | | |  __/ |   
 |_|   |_|  \___/ \___\___||___/___/\_____\___/|_| |_|\__|_|  \___/|_|_|\___|_|   
```
# Запуск
Запускать файл `main.py` для проверки работоспособности

### Требования
 - Python 3.12.2
 - os: MacOS (Не тестировал на windows и linux)

# ProcessController
### Аргументы
 - `max_proc: int = 10` - максимальное количество одновременно работающих процессов
### Методы
 - `set_max_proc` - установить новое значение количества одновременно работающих процессов
    - аргумент `max_proc: int` - максимальное количество работающих процессов
 - `start` - запуск выполнения заданий в очереди
   - аргумент `tasks: list[tuple]` - список кортежей с объектами функций и кортежем аргументов к ним.
Пример: `[(function0, (f0_arg0, f0_arg1)), (function1, (f1_arg0, f1_arg1, f1_arg2)), (function2, (f2_arg0, ))]`
   - аргумент `max_exec_time: int = None` - максимальное количество секунд, которое может работать один процесс
 - `wait_count` - возвращает число заданий, которые осталось запустить
 - `alive_count` - возвращает число выполняемых в данный момент заданий
 - `wait` - ОБЯЗАТЕЛЬНО вызывать. Ожидает пока не завершат своё выполнение все задания из очереди
### Работа
После запуска выполнения задач создаётся второй поток программы, который управляет очередью задач. 

`Starter` запускает задачи в отдельных процессах пока они есть и пока не достигнут лимит по количеству одновременно выполняемых задач, 
проверяет не вышло ли время у процесса и не закончил ли он свою работу.

Очередь (`tasks`) и активные задачи (`running_tasks`) - это списки, имеющие ту же структуру, что и аргумент `tasks` на входе. 
Списки являются поточно-ориентированными (GIL не снимается в середине обновления), поэтому это решение безопасное.

`multiprocessing` был необходим для запуска и возможности принудительной остановки выполнения задачи, когда та выполняется дольше установленного лимита.
